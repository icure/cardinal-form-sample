{"version":3,"file":"ckmeans.js","sourceRoot":"","sources":["../../tmp/conversion/ckmeans.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * For a sorted input, counting the number of unique values\n * is possible in constant time and constant memory. This is\n * a simple implementation of the algorithm.\n *\n * Values are compared with `===`, so objects and non-primitive objects\n * are not handled in any special way.\n *\n * @param {Array<*>} x an array of any kind of value\n * @returns {number} count of unique values\n * @example\n * uniqueCountSorted([1, 2, 3]); // => 3\n * uniqueCountSorted([1, 1, 1]); // => 1\n */\nfunction uniqueCountSorted(x: any[]) {\n\tlet uniqueValueCount = 0,\n\t\tlastSeenValue = undefined\n\tfor (let i = 0; i < x.length; i++) {\n\t\tif (i === 0 || x[i] !== lastSeenValue) {\n\t\t\tlastSeenValue = x[i]\n\t\t\tuniqueValueCount++\n\t\t}\n\t}\n\treturn uniqueValueCount\n}\n\n/**\n * Sort an array of numbers by their numeric value, ensuring that the\n * array is not changed in place.\n *\n * This is necessary because the default behavior of .sort\n * in JavaScript is to sort arrays as string values\n *\n *     [1, 10, 12, 102, 20].sort()\n *     // output\n *     [1, 10, 102, 12, 20]\n *\n * @param {Array<number>} x input array\n * @return {Array<number>} sorted array\n * @private\n * @example\n * numericSort([3, 2, 1]) // => [1, 2, 3]\n */\nfunction numericSort(x: number[]): number[] {\n\treturn (\n\t\tx\n\t\t\t// ensure the array is not changed in-place\n\t\t\t.slice()\n\t\t\t// comparator function that treats input as numeric\n\t\t\t.sort(function (a, b) {\n\t\t\t\treturn a - b\n\t\t\t})\n\t)\n}\n\n/**\n * Create a new column x row matrix.\n *\n * @private\n * @param {number} span\n * @param {number} rows\n * @return {Array<Array<number>>} matrix\n * @example\n * makeMatrix(10, 10);\n */\nfunction makeMatrix(span: number, rows: number) {\n\tconst matrix = []\n\tfor (let i = 0; i < span; i++) {\n\t\tconst column = []\n\t\tfor (let j = 0; j < rows; j++) {\n\t\t\tcolumn.push(0)\n\t\t}\n\t\tmatrix.push(column)\n\t}\n\treturn matrix\n}\n\n/**\n * Generates incrementally computed values based on the sums and sums of\n * squares for the data array\n *\n * @private\n * @param {number} j\n * @param {number} i\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n * @return {number}\n * @example\n * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n */\nfunction ssq(j: number, i: number, sums: number[], sumsOfSquares: number[]) {\n\tlet sji // s(j, i)\n\tif (j > 0) {\n\t\tconst muji = (sums[i] - sums[j - 1]) / (i - j + 1) // mu(j, i)\n\t\tsji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji\n\t} else {\n\t\tsji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1)\n\t}\n\tif (sji < 0) {\n\t\treturn 0\n\t}\n\treturn sji\n}\n\n/**\n * Function that recursively divides and conquers computations\n * for cluster j\n *\n * @private\n * @param {number} iMin Minimum index in cluster to be computed\n * @param {number} iMax Maximum index in cluster to be computed\n * @param {number} cluster Index of the cluster currently being computed\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n * @param {Array<number>} sums\n * @param {Array<number>} sumsOfSquares\n */\nfunction fillMatrixColumn(iMin: number, iMax: number, cluster: number, matrix: number[][], backtrackMatrix: number[][], sums: number[], sumsOfSquares: number[]) {\n\tif (iMin > iMax) {\n\t\treturn\n\t}\n\n\t// Start at midpoint between iMin and iMax\n\tconst i = Math.floor((iMin + iMax) / 2)\n\n\tmatrix[cluster][i] = matrix[cluster - 1][i - 1]\n\tbacktrackMatrix[cluster][i] = i\n\n\tlet jlow = cluster // the lower end for j\n\n\tif (iMin > cluster) {\n\t\tjlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0)\n\t}\n\tjlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0)\n\n\tlet jhigh = i - 1 // the upper end for j\n\tif (iMax < matrix[0].length - 1) {\n\t\tjhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0)\n\t}\n\n\tlet sji\n\tlet sjlowi\n\tlet ssqjlow\n\tlet ssqj\n\tfor (let j = jhigh; j >= jlow; --j) {\n\t\tsji = ssq(j, i, sums, sumsOfSquares)\n\n\t\tif (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n\t\t\tbreak\n\t\t}\n\n\t\t// Examine the lower bound of the cluster border\n\t\tsjlowi = ssq(jlow, i, sums, sumsOfSquares)\n\n\t\tssqjlow = sjlowi + matrix[cluster - 1][jlow - 1]\n\n\t\tif (ssqjlow < matrix[cluster][i]) {\n\t\t\t// Shrink the lower bound\n\t\t\tmatrix[cluster][i] = ssqjlow\n\t\t\tbacktrackMatrix[cluster][i] = jlow\n\t\t}\n\t\tjlow++\n\n\t\tssqj = sji + matrix[cluster - 1][j - 1]\n\t\tif (ssqj < matrix[cluster][i]) {\n\t\t\tmatrix[cluster][i] = ssqj\n\t\t\tbacktrackMatrix[cluster][i] = j\n\t\t}\n\t}\n\n\tfillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)\n\tfillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)\n}\n\n/**\n * Initializes the main matrices used in Ckmeans and kicks\n * off the divide and conquer cluster computation strategy\n *\n * @private\n * @param {Array<number>} data sorted array of values\n * @param {Array<Array<number>>} matrix\n * @param {Array<Array<number>>} backtrackMatrix\n */\nfunction fillMatrices(data: number[], matrix: number[][], backtrackMatrix: number[][]) {\n\tconst nValues = matrix[0].length\n\n\t// Shift values by the median to improve numeric stability\n\tconst shift = data[Math.floor(nValues / 2)]\n\n\t// Cumulative sum and cumulative sum of squares for all values in data array\n\tconst sums = [] as number[]\n\tconst sumsOfSquares = [] as number[]\n\n\t// Initialize first column in matrix & backtrackMatrix\n\tfor (let i = 0, shiftedValue; i < nValues; ++i) {\n\t\tshiftedValue = data[i] - shift\n\t\tif (i === 0) {\n\t\t\tsums.push(shiftedValue)\n\t\t\tsumsOfSquares.push(shiftedValue * shiftedValue)\n\t\t} else {\n\t\t\tsums.push(sums[i - 1] + shiftedValue)\n\t\t\tsumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue)\n\t\t}\n\n\t\t// Initialize for cluster = 0\n\t\tmatrix[0][i] = ssq(0, i, sums, sumsOfSquares)\n\t\tbacktrackMatrix[0][i] = 0\n\t}\n\n\t// Initialize the rest of the span\n\tlet iMin\n\tfor (let cluster = 1; cluster < matrix.length; ++cluster) {\n\t\tif (cluster < matrix.length - 1) {\n\t\t\tiMin = cluster\n\t\t} else {\n\t\t\t// No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n\t\t\tiMin = nValues - 1\n\t\t}\n\n\t\tfillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)\n\t}\n}\n\n/**\n * Ckmeans clustering is an improvement on heuristic-based clustering\n * approaches like Jenks. The algorithm was developed in\n * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n * to the problem of clustering numeric data into groups with the least\n * within-group sum-of-squared-deviations.\n *\n * Minimizing the difference within groups - what Wang & Song refer to as\n * `withinss`, or within sum-of-squares, means that groups are optimally\n * homogenous within and the data is split into representative groups.\n * This is very useful for visualization, where you may want to represent\n * a continuous variable in discrete color or style groups. This function\n * can provide groups that emphasize differences between data.\n *\n * Being a dynamic approach, this algorithm is based on two matrices that\n * store incrementally-computed values for squared deviations and backtracking\n * indexes.\n *\n * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n *\n * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n * this implementation does not include any code to automatically determine\n * the optimal number of clusters: this information needs to be explicitly\n * provided.\n *\n * ### References\n * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n *\n * from The R Journal Vol. 3/2, December 2011\n * @param {Array<number>} x input data, as an array of number values\n * @param {number} nClusters number of desired classes. This cannot be\n * greater than the number of values in the data array.\n * @returns {Array<Array<number>>} clustered input\n * @throws {Error} if the number of requested clusters is higher than the size of the data\n * @example\n * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n * // The input, clustered into groups of similar numbers.\n * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n */\nconst ckmeans = (x: number[], nClusters: number): number[][] => {\n\tif (nClusters > x.length) {\n\t\tthrow new Error('cannot generate more classes than there are data values')\n\t}\n\n\tconst sorted = numericSort(x)\n\t// we'll use this as the maximum number of clusters\n\tconst uniqueCount = uniqueCountSorted(sorted)\n\n\t// if all of the input values are identical, there's one cluster\n\t// with all of the input in it.\n\tif (uniqueCount === 1) {\n\t\treturn [sorted]\n\t}\n\n\t// named 'S' originally\n\tconst matrix = makeMatrix(nClusters, sorted.length)\n\t// named 'J' originally\n\tconst backtrackMatrix = makeMatrix(nClusters, sorted.length)\n\n\t// This is a dynamic programming way to solve the problem of minimizing\n\t// within-cluster sum of squares. It's similar to linear regression\n\t// in this way, and this calculation incrementally computes the\n\t// sum of squares that are later read.\n\tfillMatrices(sorted, matrix, backtrackMatrix)\n\n\t// The real work of Ckmeans clustering happens in the matrix generation:\n\t// the generated matrices encode all possible clustering combinations, and\n\t// once they're generated we can solve for the best clustering groups\n\t// very quickly.\n\tconst clusters = []\n\tlet clusterRight = backtrackMatrix[0].length - 1\n\n\t// Backtrack the clusters from the dynamic programming matrix. This\n\t// starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n\t// and moves the cluster target with the loop.\n\tfor (let cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n\t\tconst clusterLeft = backtrackMatrix[cluster][clusterRight]\n\n\t\t// fill the cluster from the sorted input by taking a slice of the\n\t\t// array. the backtrack matrix makes this easy - it stores the\n\t\t// indexes where the cluster should start and end.\n\t\tclusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1)\n\n\t\tif (cluster > 0) {\n\t\t\tclusterRight = clusterLeft - 1\n\t\t}\n\t}\n\n\treturn clusters\n}\n\nexport default ckmeans\n"]}